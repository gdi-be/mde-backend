-- Migration: Add UUID fields to nested JSON objects in JSONB columns
-- Version: V2.0.9__add_uuid_fields_to_json_objects.sql
-- Generated by: GitHub Copilot (2026-02-05)
-- FIXED: Handles NULL/missing arrays correctly without corrupting data

-- Create a temporary function to add UUID to objects in a JSONB array if missing
-- Returns the original value if not an array (including NULL)
CREATE OR REPLACE FUNCTION add_uuid_to_array_elements(arr jsonb)
RETURNS jsonb AS $$
DECLARE
    element jsonb;
    result jsonb := '[]'::jsonb;
BEGIN
    -- If NULL or not an array, return unchanged (protects against corruption)
    IF arr IS NULL THEN
        RETURN NULL;
    END IF;

    IF jsonb_typeof(arr) != 'array' THEN
        RETURN arr;
    END IF;

    FOR element IN SELECT * FROM jsonb_array_elements(arr)
    LOOP
        IF jsonb_typeof(element) = 'object' AND NOT (element ? 'id') THEN
            element := jsonb_set(element, '{id}', to_jsonb(gen_random_uuid()::text), true);
        END IF;
        result := result || element;
    END LOOP;

    RETURN result;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Create a function to add UUID to nested objects in Service.featureTypes[].columns[]
CREATE OR REPLACE FUNCTION add_uuid_to_feature_type_columns(service jsonb)
RETURNS jsonb AS $$
DECLARE
    feature_types jsonb;
    feature_type jsonb;
    updated_feature_types jsonb := '[]'::jsonb;
BEGIN
    IF service IS NULL OR NOT (service ? 'featureTypes') THEN
        RETURN service;
    END IF;

    feature_types := service->'featureTypes';
    IF jsonb_typeof(feature_types) != 'array' THEN
        RETURN service;
    END IF;

    FOR feature_type IN SELECT * FROM jsonb_array_elements(feature_types)
    LOOP
        -- Add UUID to FeatureType itself if missing
        IF jsonb_typeof(feature_type) = 'object' AND NOT (feature_type ? 'id') THEN
            feature_type := jsonb_set(feature_type, '{id}', to_jsonb(gen_random_uuid()::text), true);
        END IF;

        -- Add UUID to columns array elements if they exist
        IF feature_type ? 'columns' THEN
            feature_type := jsonb_set(
                feature_type,
                '{columns}',
                add_uuid_to_array_elements(feature_type->'columns'),
                false
            );
        END IF;

        updated_feature_types := updated_feature_types || feature_type;
    END LOOP;

    -- Update the service with the modified featureTypes
    RETURN jsonb_set(service, '{featureTypes}', updated_feature_types, false);
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Create a function to process all services in iso_metadata
CREATE OR REPLACE FUNCTION process_services(metadata jsonb)
RETURNS jsonb AS $$
DECLARE
    services jsonb;
    service jsonb;
    updated_services jsonb := '[]'::jsonb;
BEGIN
    IF metadata IS NULL OR NOT (metadata ? 'services') THEN
        RETURN metadata;
    END IF;

    services := metadata->'services';
    IF jsonb_typeof(services) != 'array' THEN
        RETURN metadata;
    END IF;

    FOR service IN SELECT * FROM jsonb_array_elements(services)
    LOOP
        -- Add UUID to Service itself if missing
        IF jsonb_typeof(service) = 'object' AND NOT (service ? 'id') THEN
            service := jsonb_set(service, '{id}', to_jsonb(gen_random_uuid()::text), true);
        END IF;

        -- Process nested featureTypes and their columns
        service := add_uuid_to_feature_type_columns(service);

        updated_services := updated_services || service;
    END LOOP;

    RETURN jsonb_set(metadata, '{services}', updated_services, false);
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Create a function to process layers map in client_metadata
CREATE OR REPLACE FUNCTION process_layers_map(metadata jsonb)
RETURNS jsonb AS $$
DECLARE
    layers_map jsonb;
    service_key text;
    layers_array jsonb;
    updated_layers_map jsonb := '{}'::jsonb;
BEGIN
    IF metadata IS NULL OR NOT (metadata ? 'layers') THEN
        RETURN metadata;
    END IF;

    layers_map := metadata->'layers';
    IF jsonb_typeof(layers_map) != 'object' THEN
        RETURN metadata;
    END IF;

    -- Iterate over each service key in the layers map
    FOR service_key IN SELECT * FROM jsonb_object_keys(layers_map)
    LOOP
        layers_array := layers_map->service_key;

        -- Add UUIDs to the layer array elements
        layers_array := add_uuid_to_array_elements(layers_array);

        -- Build the updated map
        updated_layers_map := jsonb_set(updated_layers_map, ARRAY[service_key], layers_array, true);
    END LOOP;

    RETURN jsonb_set(metadata, '{layers}', updated_layers_map, false);
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Create a function to safely update iso_metadata without corrupting missing fields
CREATE OR REPLACE FUNCTION process_iso_metadata(metadata jsonb)
RETURNS jsonb AS $$
DECLARE
    result jsonb;
BEGIN
    IF metadata IS NULL THEN
        RETURN NULL;
    END IF;

    result := metadata;

    -- Only process contacts if it exists and is an array
    IF metadata ? 'contacts' AND jsonb_typeof(metadata->'contacts') = 'array' THEN
        result := jsonb_set(result, '{contacts}', add_uuid_to_array_elements(metadata->'contacts'), false);
    END IF;

    -- Only process contentDescriptions if it exists and is an array
    IF metadata ? 'contentDescriptions' AND jsonb_typeof(metadata->'contentDescriptions') = 'array' THEN
        result := jsonb_set(result, '{contentDescriptions}', add_uuid_to_array_elements(metadata->'contentDescriptions'), false);
    END IF;

    -- Only process lineage if it exists and is an array
    IF metadata ? 'lineage' AND jsonb_typeof(metadata->'lineage') = 'array' THEN
        result := jsonb_set(result, '{lineage}', add_uuid_to_array_elements(metadata->'lineage'), false);
    END IF;

    -- Only process pointsOfContact if it exists and is an array
    IF metadata ? 'pointsOfContact' AND jsonb_typeof(metadata->'pointsOfContact') = 'array' THEN
        result := jsonb_set(result, '{pointsOfContact}', add_uuid_to_array_elements(metadata->'pointsOfContact'), false);
    END IF;

    RETURN result;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Update iso_metadata: add UUIDs to contacts, contentDescriptions, lineage, pointsOfContact
UPDATE metadata_collection
SET iso_metadata = process_iso_metadata(iso_metadata)
WHERE iso_metadata IS NOT NULL;

-- Process services with nested structures
UPDATE metadata_collection
SET iso_metadata = process_services(iso_metadata)
WHERE iso_metadata IS NOT NULL AND iso_metadata ? 'services';

-- Update client_metadata: process layers map
UPDATE metadata_collection
SET client_metadata = process_layers_map(client_metadata)
WHERE client_metadata IS NOT NULL AND client_metadata ? 'layers';

-- Clean up temporary functions
DROP FUNCTION IF EXISTS add_uuid_to_array_elements(jsonb);
DROP FUNCTION IF EXISTS add_uuid_to_feature_type_columns(jsonb);
DROP FUNCTION IF EXISTS process_services(jsonb);
DROP FUNCTION IF EXISTS process_layers_map(jsonb);
DROP FUNCTION IF EXISTS process_iso_metadata(jsonb);
